<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ìˆœì²œë§Œ MERGE POP! (ì´ë¯¸ì§€ ë²„ì „)</title>
  <style>
    body {
      margin: 0;
      background: #102027;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      color: #fff;
      font-family: system-ui, sans-serif;
    }
    #game-container {
      position: relative;
    }
    canvas {
      background: #cfe9ff;
      border-radius: 12px;
      box-shadow: 0 0 24px rgba(0,0,0,0.4);
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 18px;
      text-shadow: 0 0 3px #000;
      line-height: 1.4;
    }
    #title {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 20px;
      font-weight: 700;
      text-align: right;
      text-shadow: 0 0 3px #000;
    }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 30px;
      font-weight: 700;
      text-align: center;
      text-shadow: 0 0 5px #000;
      pointer-events: none;
      white-space: pre-line;
    }
    /* 7ë‹¨ê³„ ì„±ê³µ ì´ë¯¸ì§€ (ì˜¤ë²„ë ˆì´) */
    #success-img {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      height: 300px;
      display: none;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game" width="800" height="900"></canvas>
    <div id="ui">
      ì‹œê°„: <span id="time">0</span>ì´ˆ<br />
      ìƒíƒœ ì ìˆ˜: <span id="score">0</span>
    </div>
    <div id="title">
      ìˆœì²œë§Œ MERGE POP!<br />
      <span style="font-size:14px;">1 â†’ 2 â†’ 3 â†’ â€¦ â†’ 7</span>
    </div>
    <div id="message"></div>

    <!-- 7ë‹¨ê³„ ì„±ê³µ ì˜¤ë²„ë ˆì´ ì´ë¯¸ì§€ (7.png ì‚¬ìš©) -->
    <img id="success-img" src="7.png" alt="7ë‹¨ê³„ ì´ë¯¸ì§€" />
  </div>

  <script>
    // ====== ê¸°ë³¸ ì„¤ì • ======
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const W = canvas.width;
    const H = canvas.height;

    const TIME_LIMIT = 100;      // 100ì´ˆ ì§€ë‚˜ë©´ ê²Œì„ ì˜¤ë²„
    const TARGET_LEVEL = 7;      // ëª©í‘œ ë ˆë²¨ (ìµœì¢… ë‹¨ê³„)

    const gravity = 0.4;
    const bounce = 0.4;
    const frictionX = 0.98;
    const maxFallSpeed = 20;

    // ì»¨í…Œì´ë„ˆ ìœ„ì¹˜/í¬ê¸°
    const containerWidth = W * 0.6;
    const containerHeight = H * 0.6;
    const containerX1 = (W - containerWidth) / 2;
    const containerX2 = containerX1 + containerWidth;
    const containerYTop = (H - containerHeight) / 2;
    const containerYBottom = containerYTop + containerHeight;
    const spawnLine = containerYTop + 50;

    // ë ˆë²¨ë³„ ì´ë¯¸ì§€ í¬ê¸° (1~7: ë‹¨ê³„ / 8,9: íŠ¹ìˆ˜ ì´ë¯¸ì§€)
    const LEVEL_SIZE = {
      1: 76,
      2: 109,
      3: 142,
      4: 150,
      5: 186,
      6: 210,
      7: 220,
      8: 150, // ë ˆë²¨ì—… ì•„ì´í…œ(8ë²ˆ ì´ë¯¸ì§€)
      9: 150  // ì¥ì• ë¬¼ ë¸”ë¡(9ë²ˆ ì´ë¯¸ì§€)
    };

    // ë‹¨ê³„ ì—…ê·¸ë ˆì´ë“œìš© (1~7ê¹Œì§€ë§Œ ë‹¨ê³„)
    const MERGE_MAP = {
      1: 2,
      2: 3,
      3: 4,
      4: 5,
      5: 6,
      6: 7,
      7: 7  // 7ë‹¨ê³„ê°€ ìµœì¢…
    };

    // ====== ì´ë¯¸ì§€ ë¡œë“œ ======
    const images = {};
    for (let i = 1; i <= 9; i++) {
      const img = new Image();
      img.src = `${i}.png`; // 1.png ~ 9.png
      images[i] = img;
    }

    const backgroundImg = new Image();
    backgroundImg.src = "background.png";

    // ====== ìƒíƒœ ë³€ìˆ˜ ======
    let fruits = [];
    let nextFruit = null;
    let gameRunning = false;
    let gameOver = false;
    let startTime = 0;
    let lastTime = 0;
    let score = 0;

    // 8ë²ˆ/9ë²ˆ ì•„ì´í…œì´ ì´ íŒì—ì„œ ì´ë¯¸ ë‚˜ì™”ëŠ”ì§€ ì—¬ë¶€
    let usedItem8 = false;
    let usedItem9 = false;

    const timeEl = document.getElementById("time");
    const scoreEl = document.getElementById("score");
    const messageEl = document.getElementById("message");
    const successImg = document.getElementById("success-img");

    function randChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function nowSec() {
      return performance.now() / 1000;
    }

    function resetGame() {
      fruits = [];
      nextFruit = null;
      gameRunning = true;
      gameOver = false;
      startTime = nowSec();
      lastTime = startTime;
      score = 0;
      scoreEl.textContent = "0";
      timeEl.textContent = "0";
      messageEl.textContent = "";

      // 8,9 ì•„ì´í…œ ì‚¬ìš© ì—¬ë¶€ ì´ˆê¸°í™”
      usedItem8 = false;
      usedItem9 = false;

      // ì˜¤ë²„ë ˆì´ ì´ë¯¸ì§€ ìˆ¨ê¸°ê¸°
      if (successImg) {
        successImg.style.display = "none";
      }

      spawnNextFruit();
      requestAnimationFrame(loop);
    }

    // ====== Fruit í´ë˜ìŠ¤ ======
    class Fruit {
      constructor(x, y, level, vx = 0, vy = 0) {
        this.x = x;
        this.y = y;
        this.level = level;
        this.size = LEVEL_SIZE[level] || 80;
        this.r = this.size / 2;
        this.vx = vx;
        this.vy = vy;
        this.isFalling = true;
        this.isMovingAfterMerge = false;
        this.canMerge = true;
      }

      update(dt) {
        if (!this.isFalling && !this.isMovingAfterMerge) {
          this.vx = 0;
          this.vy = 0;
          return;
        }

        this.vx *= frictionX;

        this.vy += gravity;
        if (this.vy > maxFallSpeed) this.vy = maxFallSpeed;

        this.x += this.vx;
        this.y += this.vy;

        const leftBoundary = containerX1 + 10;
        const rightBoundary = containerX2 - 10;
        const bottomBoundary = containerYBottom - 10;

        // ì¢Œìš° ë²½ ì¶©ëŒ
        if (this.x - this.r <= leftBoundary) {
          this.x = leftBoundary + this.r;
          this.vx *= -0.5;
          if (Math.abs(this.vx) < 0.1) this.vx = 0;
        } else if (this.x + this.r >= rightBoundary) {
          this.x = rightBoundary - this.r;
          this.vx *= -0.5;
          if (Math.abs(this.vx) < 0.1) this.vx = 0;
        }

        // ë°”ë‹¥ ì¶©ëŒ
        if (this.y + this.r >= bottomBoundary) {
          this.y = bottomBoundary - this.r;
          this.vy *= -bounce;
          this.vx *= 0.8;

          if (Math.abs(this.vy) < 0.1 && Math.abs(this.vx) < 0.1) {
            this.vy = 0;
            this.vx = 0;
            this.isFalling = false;
            this.isMovingAfterMerge = false;
          }
        }
      }

      distanceTo(other) {
        const dx = this.x - other.x;
        const dy = this.y - other.y;
        return Math.hypot(dx, dy);
      }

      isColliding(other) {
        return this.distanceTo(other) <= (this.r + other.r) * 1.02;
      }

      draw(ctx) {
        const img = images[this.level];

        if (img && img.complete) {
          ctx.drawImage(
            img,
            this.x - this.r,
            this.y - this.r,
            this.size,
            this.size
          );
        } else {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
          ctx.fillStyle = "#ffffff88";
          ctx.fill();
          ctx.strokeStyle = "#000";
          ctx.stroke();

          ctx.fillStyle = "#000";
          ctx.font = `${this.r * 0.8}px Arial`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(this.level.toString(), this.x, this.y);
        }
      }
    }

    // ====== ìŠ¤í° ======
    function spawnNextFruit() {
      if (!gameRunning || gameOver) return;

      if (checkFailCondition()) {
        showFail("ì‹¤íŒ¨! ê°¯ë²Œì´ ë„ˆë¬´ ë³µì¡í•´ì¡Œì–´ìš”!");
        return;
      }

      // ê¸°ë³¸ í’€: 1~5ë‹¨ê³„
      const levelsPool = [
        1,1,1,1,
        2,2,2,
        3,3,
        4,4,
        5
      ];

      // í•œ íŒì— í•œ ë²ˆë§Œ: ì•„ì§ ì•ˆ ë‚˜ì˜¨ ê²½ìš°ì—ë§Œ ì¶”ê°€
      if (!usedItem8) levelsPool.push(8); // ë ˆë²¨ì—… ì•„ì´í…œ
      if (!usedItem9) levelsPool.push(9); // ì¥ì• ë¬¼ ë¸”ë¡

      const level = randChoice(levelsPool);

      // ë½‘íŒ ê²Œ 8 ë˜ëŠ” 9ë©´ "ì‚¬ìš©ë¨" í‘œì‹œ
      if (level === 8) usedItem8 = true;
      if (level === 9) usedItem9 = true;

      const x = (containerX1 + containerX2) / 2;
      const y = containerYTop + 25;

      nextFruit = new Fruit(x, y, level, 0, 0);
      nextFruit.isFalling = false;
    }

    // ë§ˆìš°ìŠ¤ ì´ë™
    canvas.addEventListener("mousemove", (e) => {
      if (!nextFruit || !gameRunning || gameOver) return;
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;

      const r = nextFruit.r;
      const minX = containerX1 + r + 10;
      const maxX = containerX2 - r - 10;
      nextFruit.x = Math.min(maxX, Math.max(minX, mouseX));
    });

    // í´ë¦­
    canvas.addEventListener("click", () => {
      if (!gameRunning || gameOver) {
        resetGame();
        return;
      }
      if (!nextFruit) return;

      nextFruit.isFalling = true;
      nextFruit.isMovingAfterMerge = false;
      nextFruit.vx = 0;
      nextFruit.vy = 0;
      fruits.push(nextFruit);
      nextFruit = null;

      setTimeout(spawnNextFruit, 500);
    });

    // ====== ìƒíƒœ í‘œì‹œ ======
    function showFail(text) {
      if (gameOver) return;
      gameOver = true;
      gameRunning = false;
      messageEl.textContent = text + "\n(í´ë¦­í•˜ë©´ ë‹¤ì‹œ ì‹œì‘)";
    }

    function showSuccess() {
      if (gameOver) return;
      gameOver = true;
      gameRunning = false;

      messageEl.textContent =
        `ì„±ê³µ! ${TARGET_LEVEL}ë‹¨ê³„ ì´ë¯¸ì§€ê°€ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ‰\n(í´ë¦­í•˜ë©´ ë‹¤ì‹œ ì‹œì‘)`;

      if (successImg) {
        successImg.style.display = "block";
      }
    }

    function showTimeOver() {
      if (gameOver) return;
      gameOver = true;
      gameRunning = false;
      messageEl.textContent = `ì‹œê°„ ì´ˆê³¼! ìˆœì²œë§Œì´ ìœ„í˜‘ë°›ê³  ìˆì–´ìš” ğŸ˜¢\n(í´ë¦­í•˜ë©´ ë‹¤ì‹œ ì‹œì‘)`;
    }

    function checkFailCondition() {
      for (const f of fruits) {
        if (f.isFalling || f.isMovingAfterMerge) continue;
        const topY = f.y - f.r;
        if (topY < spawnLine) return true;
      }
      return false;
    }

    // ====== ë©”ì¸ ë£¨í”„ ======
    function loop() {
      if (!gameRunning) return;

      const t = nowSec();
      const elapsed = Math.floor(t - startTime);
      timeEl.textContent = elapsed.toString();

      if (elapsed >= TIME_LIMIT) {
        timeEl.textContent = TIME_LIMIT.toString();
        showTimeOver();
        return;
      }

      const dt = t - lastTime;
      lastTime = t;

      update(dt);
      draw();

      if (!gameOver) {
        requestAnimationFrame(loop);
      }
    }

    // ====== ì—…ë°ì´íŠ¸ ======
    function update(dt) {
      // 1. ë¬¼ë¦¬
      for (const f of fruits) {
        f.update(dt);
      }

      // 2. í•©ì¹˜ê¸° + 8/9 íŠ¹ìˆ˜ í–‰ë™
      const toRemove = new Set();
      const toAdd = [];

      for (let i = 0; i < fruits.length; i++) {
        for (let j = i + 1; j < fruits.length; j++) {
          const a = fruits[i];
          const b = fruits[j];
          if (!a || !b) continue;
          if (toRemove.has(i) || toRemove.has(j)) continue;
          if (!a.isColliding(b)) continue;

          // ğŸ’  8ë²ˆ ì´ë¯¸ì§€: ë ˆë²¨ ì—… ì•„ì´í…œ
          if (a.level === 8 && b.level >= 1 && b.level <= 7) {
            if (b.level < TARGET_LEVEL) {
              b.level += 1;
              b.size = LEVEL_SIZE[b.level] || b.size;
              b.r = b.size / 2;
              b.vy = -10;
            }
            toRemove.add(i);

            if (b.level === TARGET_LEVEL) {
              showSuccess();
            }
            continue;
          }

          if (b.level === 8 && a.level >= 1 && a.level <= 7) {
            if (a.level < TARGET_LEVEL) {
              a.level += 1;
              a.size = LEVEL_SIZE[a.level] || a.size;
              a.r = a.size / 2;
              a.vy = -10;
            }
            toRemove.add(j);

            if (a.level === TARGET_LEVEL) {
              showSuccess();
            }
            continue;
          }

          // ğŸ§± 9ë²ˆ ì´ë¯¸ì§€: ì¥ì• ë¬¼ ë¸”ë¡ (ë ˆë²¨ ë³€í™” ì—†ìŒ)
          if (a.level === 9 || b.level === 9) {
            // ë¬¼ë¦¬ì  ë°€ì–´ë‚´ê¸°ëŠ” ì•„ë˜ì—ì„œ ì²˜ë¦¬í•˜ë¯€ë¡œ ì—¬ê¸°ì„  ì•„ë¬´ ê²ƒë„ ì•ˆ í•¨
            continue;
          }

          // ğŸŠ ì¼ë°˜ í•©ì¹˜ê¸° (1~6ê¹Œì§€ë§Œ í•©ì„±, 7ì€ ìµœì¢…)
          if (a.level === b.level &&
              a.level < TARGET_LEVEL &&
              a.canMerge &&
              b.canMerge) {

            const newLevel = MERGE_MAP[a.level] || a.level;
            const newX = (a.x + b.x) / 2;
            const newY = (a.y + b.y) / 2;

            const nf = new Fruit(
              newX,
              newY,
              newLevel,
              (Math.random() * 6 - 3),
              -10
            );
            nf.isFalling = true;
            nf.isMovingAfterMerge = true;
            toAdd.push(nf);

            toRemove.add(i);
            toRemove.add(j);

            a.canMerge = false;
            b.canMerge = false;
            setTimeout(() => {
              a.canMerge = true;
              b.canMerge = true;
            }, 200);

            score += newLevel * 10;
            scoreEl.textContent = score.toString();

            if (newLevel === TARGET_LEVEL) {
              showSuccess();
            }
          }
        }
      }

      // ì œê±° & ì¶”ê°€ ì ìš©
      if (toRemove.size > 0) {
        const newList = [];
        for (let i = 0; i < fruits.length; i++) {
          if (!toRemove.has(i)) newList.push(fruits[i]);
        }
        fruits = newList;
      }
      fruits.push(...toAdd);

      // 3. ê²¹ì¹¨ ë°€ì–´ë‚´ê¸° (ë¬¼ë¦¬)
      for (let rep = 0; rep < 3; rep++) {
        for (let i = 0; i < fruits.length; i++) {
          for (let j = i + 1; j < fruits.length; j++) {
            const a = fruits[i];
            const b = fruits[j];
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            let dist = Math.hypot(dx, dy);
            const minDist = a.r + b.r;
            if (dist < minDist && dist > 0) {
              const overlap = (minDist - dist) * 0.5;
              const ux = dx / dist;
              const uy = dy / dist;
              a.x += ux * overlap;
              a.y += uy * overlap;
              b.x -= ux * overlap;
              b.y -= uy * overlap;
            }
          }
        }
      }

      // 4. ì»¨í…Œì´ë„ˆ ì•ˆìœ¼ë¡œ í´ë¨í”„
      const leftBoundary = containerX1 + 10;
      const rightBoundary = containerX2 - 10;
      const bottomBoundary = containerYBottom - 10;
      const topBoundary = containerYTop + 10;

      for (const f of fruits) {
        if (f.x - f.r < leftBoundary) {
          f.x = leftBoundary + f.r;
        }
        if (f.x + f.r > rightBoundary) {
          f.x = rightBoundary - f.r;
        }
        if (f.y + f.r > bottomBoundary) {
          f.y = bottomBoundary - f.r;
        }
        if (f.y - f.r < topBoundary) {
          f.y = topBoundary + f.r;
        }
      }

      // 5. ì‹¤íŒ¨ ì²´í¬
      if (checkFailCondition()) {
        showFail("ì‹¤íŒ¨! ê°¯ë²Œì´ ë„ˆë¬´ ë³µì¡í•´ì¡Œì–´ìš”!");
      }
    }

    // ====== ê·¸ë¦¬ê¸° ======
    function drawContainer(ctx) {
      ctx.save();
      ctx.fillStyle = "#5D4037";
      ctx.fillRect(containerX1, containerYTop, 10, containerHeight);
      ctx.fillRect(containerX2 - 10, containerYTop, 10, containerHeight);
      ctx.fillRect(containerX1, containerYBottom - 10, containerWidth, 10);

      ctx.setLineDash([5,5]);
      ctx.strokeStyle = "#455A64";
      ctx.beginPath();
      ctx.moveTo(containerX1, spawnLine);
      ctx.lineTo(containerX2, spawnLine);
      ctx.stroke();
      ctx.restore();
    }

    function draw() {
      // ë°°ê²½
      if (backgroundImg && backgroundImg.complete) {
        ctx.drawImage(backgroundImg, 0, 0, W, H);
      } else {
        const grd = ctx.createLinearGradient(0, 0, 0, H);
        grd.addColorStop(0, "#90CAF9");
        grd.addColorStop(0.4, "#E3F2FD");
        grd.addColorStop(1, "#A5D6A7");
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, W, H);
      }

      drawContainer(ctx);

      for (const f of fruits) {
        f.draw(ctx);
      }

      if (nextFruit && !gameOver) {
        nextFruit.draw(ctx);
      }
    }

    // ====== ì‹œì‘ ======
    resetGame();
  </script>
</body>
</html>
