<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ìˆœì²œë§Œ MERGE POP! (ì›¹ë²„ì „)</title>
  <style>
    body {
      margin: 0;
      background: #102027;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      color: #fff;
      font-family: system-ui, sans-serif;
    }
    #game-container {
      position: relative;
    }
    canvas {
      background: #cfe9ff;
      border-radius: 12px;
      box-shadow: 0 0 24px rgba(0,0,0,0.4);
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 18px;
      text-shadow: 0 0 3px #000;
      line-height: 1.4;
    }
    #title {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 20px;
      font-weight: 700;
      text-align: right;
      text-shadow: 0 0 3px #000;
    }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 30px;
      font-weight: 700;
      text-align: center;
      text-shadow: 0 0 5px #000;
      pointer-events: none;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game" width="800" height="900"></canvas>
    <div id="ui">
      ì‹œê°„: <span id="time">0</span>ì´ˆ<br />
      ìƒíƒœ ì ìˆ˜: <span id="score">0</span>
    </div>
    <div id="title">
      ìˆœì²œë§Œ MERGE POP!<br />
      <span style="font-size:14px;">ê°ˆëŒ€ â†’ ì¡°ê°œ â†’ ë†ê²Œ â†’ ì§±ëš±ì–´ â†’ ê²€ë¨¸ê°ˆ â†’ í‘ë‘ë£¨ë¯¸ â†’ ìˆœì²œë§Œ</span>
    </div>
    <div id="message"></div>
  </div>

  <script>
    // ====== ê¸°ë³¸ ì„¤ì • ======
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const W = canvas.width;
    const H = canvas.height;

    const TIME_LIMIT = 100;       // 100ì´ˆ ì§€ë‚˜ë©´ ê²Œì„ ì˜¤ë²„
    const TARGET_LEVEL = 7;       // 7ë‹¨ê³„ = ìˆœì²œë§Œ
    const gravity = 0.4;
    const bounce = 0.4;
    const frictionX = 0.98;
    const maxFallSpeed = 20;

    // í†µ(ì»¨í…Œì´ë„ˆ) ì„¤ì • (í™”ë©´ ê°€ìš´ë°)
    const containerWidth = W * 0.6;
    const containerHeight = H * 0.6;
    const containerX1 = (W - containerWidth) / 2;
    const containerX2 = containerX1 + containerWidth;
    const containerYTop = (H - containerHeight) / 2;
    const containerYBottom = containerYTop + containerHeight;

    const spawnLine = containerYTop + 50; // ìŠ¤í° íŒì • ë¼ì¸

    // ë ˆë²¨ë³„ í¬ê¸° (ëŒ€ëµ)
    const LEVEL_SIZE = {
      1: 38,  // ê°ˆëŒ€
      2: 48,  // ì¡°ê°œ
      3: 56,  // ë†ê²Œ
      4: 64,  // ì§±ëš±ì–´
      5: 72,  // ê²€ì€ë¨¸ë¦¬ê°ˆë§¤ê¸°
      6: 80,  // í‘ë‘ë£¨ë¯¸
      7: 90,  // ìˆœì²œë§Œ
      8: 80,  // ì €ì–´ìƒˆ (ë³´ë„ˆìŠ¤ ëŠë‚Œ)
      9: 80   // ë³´í˜¸êµ¬ì—­ (ìµœì¢… ìƒì§•)
    };

    // í•©ì³ì¡Œì„ ë•Œ ë‹¤ìŒ ë‹¨ê³„
    const MERGE_MAP = {
      1: 2,
      2: 3,
      3: 4,
      4: 5,
      5: 6,
      6: 7,
      7: 8,
      8: 9,
      9: 9
    };

    // ë ˆë²¨ â†’ ìƒë¬¼ ì´ë¦„ (í‘œì‹œìš©)
    const ECO_LABELS = {
      1: "ê°ˆëŒ€",
      2: "ì¡°ê°œ",
      3: "ë†ê²Œ",
      4: "ì§±ëš±ì–´",
      5: "ê²€ë¨¸ê°ˆ",      // ê²€ì€ë¨¸ë¦¬ê°ˆë§¤ê¸°
      6: "í‘ë‘ë£¨ë¯¸",
      7: "ìˆœì²œë§Œ",
      8: "ì €ì–´ìƒˆ",
      9: "ë³´í˜¸êµ¬ì—­"
    };

    // ë ˆë²¨ â†’ ìƒ‰ê¹” (ëŒ€ëµ ìƒíƒœê³„ ëŠë‚Œ)
    const ECO_COLORS = {
      1: "#7CB342", // ê°ˆëŒ€: ì´ˆë¡
      2: "#FFF3E0", // ì¡°ê°œ: í¬ë¦¼ìƒ‰
      3: "#FF8A65", // ë†ê²Œ: ì£¼í™©
      4: "#8D6E63", // ì§±ëš±ì–´: ê°ˆìƒ‰
      5: "#CFD8DC", // ê²€ì€ë¨¸ë¦¬ê°ˆë§¤ê¸°: íšŒìƒ‰/í°ìƒ‰
      6: "#E0F7FA", // í‘ë‘ë£¨ë¯¸: ì²­ë¡/í°
      7: "#4DB6AC", // ìˆœì²œë§Œ: ì²­ë¡(ìŠµì§€)
      8: "#FFF59D", // ì €ì–´ìƒˆ: ë…¸ë‘ ëŠë‚Œ
      9: "#80CBC4"  // ë³´í˜¸êµ¬ì—­: ì§™ì€ ì²­ë¡
    };

    // ====== ìƒíƒœ ë³€ìˆ˜ ======
    let fruits = [];
    let nextFruit = null;
    let gameRunning = false;
    let gameOver = false;
    let startTime = 0;
    let lastTime = 0;
    let score = 0;

    const timeEl = document.getElementById("time");
    const scoreEl = document.getElementById("score");
    const messageEl = document.getElementById("message");

    function randChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function nowSec() {
      return performance.now() / 1000;
    }

    function resetGame() {
      fruits = [];
      nextFruit = null;
      gameRunning = true;
      gameOver = false;
      startTime = nowSec();
      lastTime = startTime;
      score = 0;
      scoreEl.textContent = "0";
      timeEl.textContent = "0";
      messageEl.textContent = "";
      spawnNextFruit();
      requestAnimationFrame(loop);
    }

    // ====== ìƒë¬¼(ê³¼ì¼) í´ë˜ìŠ¤ ======
    class Fruit {
      constructor(x, y, level, vx = 0, vy = 0) {
        this.x = x;
        this.y = y;
        this.level = level;
        this.size = LEVEL_SIZE[level] || 40;
        this.r = this.size / 2;
        this.vx = vx;
        this.vy = vy;
        this.isFalling = true;
        this.isMovingAfterMerge = false;
        this.canMerge = true;
      }

      update(dt) {
        if (!this.isFalling && !this.isMovingAfterMerge) {
          this.vx = 0;
          this.vy = 0;
          return;
        }

        // ìˆ˜í‰ ë§ˆì°°
        this.vx *= frictionX;

        // ì¤‘ë ¥
        this.vy += gravity;
        if (this.vy > maxFallSpeed) this.vy = maxFallSpeed;

        this.x += this.vx;
        this.y += this.vy;

        const leftBoundary = containerX1 + 10;
        const rightBoundary = containerX2 - 10;
        const bottomBoundary = containerYBottom - 10;

        // ì¢Œìš° ë²½
        if (this.x - this.r <= leftBoundary) {
          this.x = leftBoundary + this.r;
          this.vx *= -0.5;
          if (Math.abs(this.vx) < 0.1) this.vx = 0;
        } else if (this.x + this.r >= rightBoundary) {
          this.x = rightBoundary - this.r;
          this.vx *= -0.5;
          if (Math.abs(this.vx) < 0.1) this.vx = 0;
        }

        // ë°”ë‹¥
        if (this.y + this.r >= bottomBoundary) {
          this.y = bottomBoundary - this.r;
          this.vy *= -bounce;
          this.vx *= 0.8;

          if (Math.abs(this.vy) < 0.1 && Math.abs(this.vx) < 0.1) {
            this.vy = 0;
            this.vx = 0;
            this.isFalling = false;
            this.isMovingAfterMerge = false;
          }
        }
      }

      distanceTo(other) {
        const dx = this.x - other.x;
        const dy = this.y - other.y;
        return Math.hypot(dx, dy);
      }

      isColliding(other) {
        return this.distanceTo(other) < (this.r + other.r) * 0.98;
      }

      draw(ctx) {
        const c = ECO_COLORS[this.level] || "#cccccc";
        const label = ECO_LABELS[this.level] || this.level.toString();

        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fillStyle = c;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#ffffff";
        ctx.stroke();

        // í…ìŠ¤íŠ¸ (ìƒë¬¼ ì´ë¦„)
        ctx.fillStyle = "#000000";
        ctx.font = `${this.r * 0.8}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(label, this.x, this.y);
        ctx.restore();
      }
    }

    // ====== ìŠ¤í° ======
    function spawnNextFruit() {
      if (!gameRunning || gameOver) return;

      // í™”ë©´ ê½‰ ì°¼ëŠ”ì§€ ë¨¼ì € í™•ì¸
      if (checkFailCondition()) {
        showFail("ì‹¤íŒ¨! ê°¯ë²Œì´ ë„ˆë¬´ ë³µì¡í•´ì¡Œì–´ìš”!");
        return;
      }

      // ì´ˆê¸° ë“±ì¥ ë ˆë²¨ í’€ (ê°ˆëŒ€~ì§±ëš±ì–´ ì¤‘ì‹¬)
      const levelsPool = [1,1,1,1, 2,2,2, 3,3, 4,4, 5];
      const level = randChoice(levelsPool);
      const size = LEVEL_SIZE[level] || 40;
      const r = size / 2;

      const x = (containerX1 + containerX2) / 2;
      const y = containerYTop + 25;

      nextFruit = new Fruit(x, y, level, 0, 0);
      nextFruit.isFalling = false;
    }

    // ë§ˆìš°ìŠ¤ ì´ë™ â†’ ë¯¸ë¦¬ë³´ê¸° X ì¢Œí‘œ ì´ë™
    canvas.addEventListener("mousemove", (e) => {
      if (!nextFruit || !gameRunning || gameOver) return;
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;

      const r = nextFruit.r;
      const minX = containerX1 + r + 10;
      const maxX = containerX2 - r - 10;
      nextFruit.x = Math.min(maxX, Math.max(minX, mouseX));
    });

    // í´ë¦­ â†’ ìƒë¬¼ ë–¨ì–´ëœ¨ë¦¬ê¸° / ê²Œì„ ì¬ì‹œì‘
    canvas.addEventListener("click", () => {
      if (!gameRunning || gameOver) {
        resetGame();
        return;
      }
      if (!nextFruit) return;

      nextFruit.isFalling = true;
      nextFruit.isMovingAfterMerge = false;
      nextFruit.vx = 0;
      nextFruit.vy = 0;
      fruits.push(nextFruit);
      nextFruit = null;

      setTimeout(spawnNextFruit, 500);
    });

    // ====== ìƒíƒœ í‘œì‹œ ======
    function showFail(text) {
      if (gameOver) return;
      gameOver = true;
      gameRunning = false;
      messageEl.textContent = text + "\n(í´ë¦­í•˜ë©´ ë‹¤ì‹œ ì‹œì‘)";
    }

    function showSuccess() {
      if (gameOver) return;
      gameOver = true;
      gameRunning = false;
      messageEl.textContent = `ì„±ê³µ! 7ë‹¨ê³„ ìˆœì²œë§Œì´ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸŒ¿\n(í´ë¦­í•˜ë©´ ë‹¤ì‹œ ì‹œì‘)`;
    }

    function showTimeOver() {
      if (gameOver) return;
      gameOver = true;
      gameRunning = false;
      messageEl.textContent = `ì‹œê°„ ì´ˆê³¼! ìˆœì²œë§Œì´ ìœ„í˜‘ë°›ê³  ìˆì–´ìš” ğŸ˜¢\n(í´ë¦­í•˜ë©´ ë‹¤ì‹œ ì‹œì‘)`;
    }

    function checkFailCondition() {
      // resting ìƒíƒœ ìƒë¬¼ì´ spawnLine ìœ„ë¡œ ì˜¬ë¼ì˜¤ë©´ ì‹¤íŒ¨
      for (const f of fruits) {
        if (f.isFalling || f.isMovingAfterMerge) continue;
        const topY = f.y - f.r;
        if (topY < spawnLine) return true;
      }
      return false;
    }

    // ====== ë©”ì¸ ë£¨í”„ ======
    function loop() {
      if (!gameRunning) return;

      const t = nowSec();
      const elapsed = Math.floor(t - startTime);
      timeEl.textContent = elapsed.toString();

      if (elapsed >= TIME_LIMIT) {
        timeEl.textContent = TIME_LIMIT.toString();
        showTimeOver();
        return;
      }

      const dt = t - lastTime;
      lastTime = t;

      update(dt);
      draw();

      if (!gameOver) {
        requestAnimationFrame(loop);
      }
    }

    // ====== ë¬¼ë¦¬ & í•©ì¹˜ê¸° ======
    function update(dt) {
      // 1. ë¬¼ë¦¬
      for (const f of fruits) {
        f.update(dt);
      }

      // 2. í•©ì¹˜ê¸°
      const toRemove = new Set();
      const toAdd = [];

      for (let i = 0; i < fruits.length; i++) {
        for (let j = i + 1; j < fruits.length; j++) {
          const a = fruits[i];
          const b = fruits[j];

          if (!a || !b) continue;
          if (toRemove.has(i) || toRemove.has(j)) continue;
          if (!a.isColliding(b)) continue;

          // (1) ê°™ì€ ë ˆë²¨ & 9 ë¯¸ë§Œ â†’ í•©ì¹˜ê¸°
          if (a.level === b.level && a.level !== 9 && a.canMerge && b.canMerge) {
            const newLevel = MERGE_MAP[a.level] || a.level;
            const newX = (a.x + b.x) / 2;
            const newY = (a.y + b.y) / 2;

            const nf = new Fruit(newX, newY, newLevel, (Math.random() * 6 - 3), -10);
            nf.isFalling = true;
            nf.isMovingAfterMerge = true;
            toAdd.push(nf);

            toRemove.add(i);
            toRemove.add(j);

            a.canMerge = false;
            b.canMerge = false;
            setTimeout(() => {
              a.canMerge = true;
              b.canMerge = true;
            }, 200);

            score += newLevel * 10;
            scoreEl.textContent = score.toString();

            if (newLevel === TARGET_LEVEL) {
              showSuccess();
              return;
            }
          }
        }
      }

      // 3. ì œê±° & ì¶”ê°€
      if (toRemove.size > 0) {
        const newList = [];
        for (let i = 0; i < fruits.length; i++) {
          if (!toRemove.has(i)) {
            newList.push(fruits[i]);
          }
        }
        fruits = newList;
      }
      fruits.push(...toAdd);

      // 4. ê²¹ì¹¨ ë°€ì–´ë‚´ê¸° (ê°„ë‹¨)
      for (let rep = 0; rep < 3; rep++) {
        for (let i = 0; i < fruits.length; i++) {
          for (let j = i + 1; j < fruits.length; j++) {
            const a = fruits[i];
            const b = fruits[j];
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            let dist = Math.hypot(dx, dy);
            const minDist = a.r + b.r;
            if (dist < minDist && dist > 0) {
              const overlap = (minDist - dist) * 0.5;
              const ux = dx / dist;
              const uy = dy / dist;
              a.x += ux * overlap;
              a.y += uy * overlap;
              b.x -= ux * overlap;
              b.y -= uy * overlap;
            }
          }
        }
      }

      // 5. ì‹¤íŒ¨ ì¡°ê±´
      if (checkFailCondition()) {
        showFail("ì‹¤íŒ¨! ê°¯ë²Œì´ ë„ˆë¬´ ë³µì¡í•´ì¡Œì–´ìš”!");
      }
    }

    // ====== ê·¸ë¦¬ê¸° ======
    function drawContainer(ctx) {
      ctx.save();
      ctx.fillStyle = "#5D4037"; // ê°¯ë²Œ ë‘‘ ëŠë‚Œ
      // ì™¼ìª½ ë‘‘
      ctx.fillRect(containerX1, containerYTop, 10, containerHeight);
      // ì˜¤ë¥¸ìª½ ë‘‘
      ctx.fillRect(containerX2 - 10, containerYTop, 10, containerHeight);
      // ë°”ë‹¥
      ctx.fillRect(containerX1, containerYBottom - 10, containerWidth, 10);

      // ìŠ¤í° ë¼ì¸ (ì ì„ ) - "ìƒíƒœê³„ í•œê³„ì„ " ëŠë‚Œ
      ctx.setLineDash([5,5]);
      ctx.strokeStyle = "#455A64";
      ctx.beginPath();
      ctx.moveTo(containerX1, spawnLine);
      ctx.lineTo(containerX2, spawnLine);
      ctx.stroke();
      ctx.restore();
    }

    function draw() {
      // ë°°ê²½: í•˜ëŠ˜ â†’ ìˆœì²œë§Œ ëŠë‚Œ ê·¸ë¼ë°ì´ì…˜
      const grd = ctx.createLinearGradient(0, 0, 0, H);
      grd.addColorStop(0, "#90CAF9"); // í•˜ëŠ˜
      grd.addColorStop(0.4, "#E3F2FD");
      grd.addColorStop(1, "#A5D6A7"); // ê°ˆëŒ€ë°­/ìŠµì§€
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, W, H);

      drawContainer(ctx);

      // ìƒë¬¼ë“¤
      for (const f of fruits) {
        f.draw(ctx);
      }

      // ìœ„ìª½ ë¯¸ë¦¬ë³´ê¸°
      if (nextFruit && !gameOver) {
        nextFruit.draw(ctx);
      }
    }

    // ====== ì‹œì‘ ======
    resetGame();
  </script>
</body>
</html>
