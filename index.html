<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ìˆœì²œë§Œ MERGE POP! (ì´ë¯¸ì§€ ë²„ì „)</title>
  <style>
    body {
      margin: 0;
      background: #102027;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      color: #fff;
      font-family: system-ui, sans-serif;
    }
    #game-container {
      position: relative;
    }
    canvas {
      background: #cfe9ff;
      border-radius: 12px;
      box-shadow: 0 0 24px rgba(0,0,0,0.4);
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 18px;
      text-shadow: 0 0 3px #000;
      line-height: 1.4;
    }
    #title {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 20px;
      font-weight: 700;
      text-align: right;
      text-shadow: 0 0 3px #000;
    }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 30px;
      font-weight: 700;
      text-align: center;
      text-shadow: 0 0 5px #000;
      pointer-events: none;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game" width="800" height="900"></canvas>
    <div id="ui">
      ì‹œê°„: <span id="time">0</span>ì´ˆ<br />
      ìƒíƒœ ì ìˆ˜: <span id="score">0</span>
    </div>
    <div id="title">
      ìˆœì²œë§Œ MERGE POP!<br />
      <span style="font-size:14px;">1 â†’ 2 â†’ 3 â†’ â€¦ â†’ 9</span>
    </div>
    <div id="message"></div>
  </div>

  <script>
    // ====== ê¸°ë³¸ ì„¤ì • ======
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const W = canvas.width;
    const H = canvas.height;

    const TIME_LIMIT = 100;      // 100ì´ˆ ì§€ë‚˜ë©´ ê²Œì„ ì˜¤ë²„
    const TARGET_LEVEL = 7;      // ëª©í‘œ ë ˆë²¨ (7ë²ˆ ì´ë¯¸ì§€ê°€ ìˆœì²œë§Œì´ë¼ë©´ 7)

    const gravity = 0.4;
    const bounce = 0.4;
    const frictionX = 0.98;
    const maxFallSpeed = 20;

    // ì»¨í…Œì´ë„ˆ ìœ„ì¹˜/í¬ê¸°
    const containerWidth = W * 0.6;
    const containerHeight = H * 0.6;
    const containerX1 = (W - containerWidth) / 2;
    const containerX2 = containerX1 + containerWidth;
    const containerYTop = (H - containerHeight) / 2;
    const containerYBottom = containerYTop + containerHeight;
    const spawnLine = containerYTop + 50;

    // ë ˆë²¨ë³„ ì´ë¯¸ì§€ í¬ê¸° (px) - í•„ìš”í•˜ë©´ ì§ì ‘ ìˆ˜ì •í•´ì„œ ë§ì¶”ë©´ ë¨
    const LEVEL_SIZE = {
      1: 76,
      2: 109,
      3: 142,
      4: 150,
      5: 186,
      6: 210,
      7: 220,
      8: 150,
      9: 150
    };

    // í•©ì³ì¡Œì„ ë•Œ ë‹¤ìŒ ë ˆë²¨
    const MERGE_MAP = {
      1: 2,
      2: 3,
      3: 4,
      4: 5,
      5: 6,
      6: 7,
      7: 8,
      8: 9,
      9: 9
    };

    // ====== ì´ë¯¸ì§€ ë¡œë“œ ======
    const images = {};
    for (let i = 1; i <= 9; i++) {
      const img = new Image();
      img.src = `${i}.png`; // 1.png ~ 9.png
      images[i] = img;
    }

    const backgroundImg = new Image();
    backgroundImg.src = "background.png";

    // ====== ìƒíƒœ ë³€ìˆ˜ ======
    let fruits = [];
    let nextFruit = null;
    let gameRunning = false;
    let gameOver = false;
    let startTime = 0;
    let lastTime = 0;
    let score = 0;

    const timeEl = document.getElementById("time");
    const scoreEl = document.getElementById("score");
    const messageEl = document.getElementById("message");

    function randChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function nowSec() {
      return performance.now() / 1000;
    }

    function resetGame() {
      fruits = [];
      nextFruit = null;
      gameRunning = true;
      gameOver = false;
      startTime = nowSec();
      lastTime = startTime;
      score = 0;
      scoreEl.textContent = "0";
      timeEl.textContent = "0";
      messageEl.textContent = "";
      spawnNextFruit();
      requestAnimationFrame(loop);
    }

    // ====== Fruit í´ë˜ìŠ¤ ======
    class Fruit {
      constructor(x, y, level, vx = 0, vy = 0) {
        this.x = x;
        this.y = y;
        this.level = level;
        this.size = LEVEL_SIZE[level] || 80; // ì‚¬ì´ì¦ˆ ì—†ìœ¼ë©´ ê¸°ë³¸ 80
        this.r = this.size / 2;
        this.vx = vx;
        this.vy = vy;
        this.isFalling = true;
        this.isMovingAfterMerge = false;
        this.canMerge = true;
      }

      function update(dt) {
  // 1. ë¬¼ë¦¬
  for (const f of fruits) {
    f.update(dt);
  }

  // 2. í•©ì¹˜ê¸°
  const toRemove = new Set();
  const toAdd = [];

  for (let i = 0; i < fruits.length; i++) {
    for (let j = i + 1; j < fruits.length; j++) {
      const a = fruits[i];
      const b = fruits[j];
      if (!a || !b) continue;
      if (toRemove.has(i) || toRemove.has(j)) continue;
      if (!a.isColliding(b)) continue;

      if (a.level === b.level && a.level !== 9 && a.canMerge && b.canMerge) {
        const newLevel = MERGE_MAP[a.level] || a.level;
        const newX = (a.x + b.x) / 2;
        const newY = (a.y + b.y) / 2;

        const nf = new Fruit(
          newX,
          newY,
          newLevel,
          (Math.random() * 6 - 3),
          -10
        );
        nf.isFalling = true;
        nf.isMovingAfterMerge = true;
        toAdd.push(nf);

        toRemove.add(i);
        toRemove.add(j);

        a.canMerge = false;
        b.canMerge = false;
        setTimeout(() => {
          a.canMerge = true;
          b.canMerge = true;
        }, 200);

        score += newLevel * 10;
        scoreEl.textContent = score.toString();

        if (newLevel === TARGET_LEVEL) {
          showSuccess();
          return;
        }
      }
    }
  }

  // ì œê±° & ì¶”ê°€
  if (toRemove.size > 0) {
    const newList = [];
    for (let i = 0; i < fruits.length; i++) {
      if (!toRemove.has(i)) newList.push(fruits[i]);
    }
    fruits = newList;
  }
  fruits.push(...toAdd);

  // 3. ê²¹ì¹¨ ë°€ì–´ë‚´ê¸°
  for (let rep = 0; rep < 3; rep++) {
    for (let i = 0; i < fruits.length; i++) {
      for (let j = i + 1; j < fruits.length; j++) {
        const a = fruits[i];
        const b = fruits[j];
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        let dist = Math.hypot(dx, dy);
        const minDist = a.r + b.r;
        if (dist < minDist && dist > 0) {
          const overlap = (minDist - dist) * 0.5;
          const ux = dx / dist;
          const uy = dy / dist;
          a.x += ux * overlap;
          a.y += uy * overlap;
          b.x -= ux * overlap;
          b.y -= uy * overlap;
        }
      }
    }
  }

  // ğŸ”¹ 4. ë²½/ë°”ë‹¥ ì•ˆìœ¼ë¡œ ë‹¤ì‹œ ëŒì–´ë„£ê¸°(ì—¬ê¸°ê°€ ìƒˆë¡œ ì¶”ê°€ë˜ëŠ” ë¶€ë¶„)
  const leftBoundary = containerX1 + 10;
  const rightBoundary = containerX2 - 10;
  const bottomBoundary = containerYBottom - 10;

  for (const f of fruits) {
    if (f.x - f.r < leftBoundary) {
      f.x = leftBoundary + f.r;
    }
    if (f.x + f.r > rightBoundary) {
      f.x = rightBoundary - f.r;
    }
    if (f.y + f.r > bottomBoundary) {
      f.y = bottomBoundary - f.r;
    }
  }

  // 5. ì‹¤íŒ¨ ì²´í¬
  if (checkFailCondition()) {
    showFail("ì‹¤íŒ¨! ê°¯ë²Œì´ ë„ˆë¬´ ë³µì¡í•´ì¡Œì–´ìš”!");
  }
}

      distanceTo(other) {
        const dx = this.x - other.x;
        const dy = this.y - other.y;
        return Math.hypot(dx, dy);
      }

      isColliding(other) {
        return this.distanceTo(other) < (this.r + other.r) * 0.98;
      }

      draw(ctx) {
        const img = images[this.level];

        if (img && img.complete) {
          // ì´ë¯¸ì§€ ì¤‘ì‹¬ì´ (x, y)ì— ì˜¤ë„ë¡ ê·¸ë¦¼
          ctx.drawImage(
            img,
            this.x - this.r,
            this.y - this.r,
            this.size,
            this.size
          );
        } else {
          // ì´ë¯¸ì§€ ë¡œë“œ ì „ ì„ì‹œ ì›
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
          ctx.fillStyle = "#ffffff88";
          ctx.fill();
          ctx.strokeStyle = "#000";
          ctx.stroke();
        }
      }
    }

    // ====== ìŠ¤í° ======
    function spawnNextFruit() {
      if (!gameRunning || gameOver) return;

      if (checkFailCondition()) {
        showFail("ì‹¤íŒ¨! ê°¯ë²Œì´ ë„ˆë¬´ ë³µì¡í•´ì¡Œì–´ìš”!");
        return;
      }

      // ì´ˆë°˜ ë“±ì¥ ë ˆë²¨ í’€ (1~5 ìœ„ì£¼)
      const levelsPool = [1,1,1,1, 2,2,2, 3,3, 4,4, 5];
      const level = randChoice(levelsPool);

      const x = (containerX1 + containerX2) / 2;
      const y = containerYTop + 25;

      nextFruit = new Fruit(x, y, level, 0, 0);
      nextFruit.isFalling = false;
    }

    // ë§ˆìš°ìŠ¤ ì´ë™ìœ¼ë¡œ X ì¡°ì •
    canvas.addEventListener("mousemove", (e) => {
      if (!nextFruit || !gameRunning || gameOver) return;
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;

      const r = nextFruit.r;
      const minX = containerX1 + r + 10;
      const maxX = containerX2 - r - 10;
      nextFruit.x = Math.min(maxX, Math.max(minX, mouseX));
    });

    // í´ë¦­ â†’ ë–¨ì–´ëœ¨ë¦¬ê¸° / ì¬ì‹œì‘
    canvas.addEventListener("click", () => {
      if (!gameRunning || gameOver) {
        resetGame();
        return;
      }
      if (!nextFruit) return;

      nextFruit.isFalling = true;
      nextFruit.isMovingAfterMerge = false;
      nextFruit.vx = 0;
      nextFruit.vy = 0;
      fruits.push(nextFruit);
      nextFruit = null;

      setTimeout(spawnNextFruit, 500);
    });

    // ====== ìƒíƒœ í‘œì‹œ ======
    function showFail(text) {
      if (gameOver) return;
      gameOver = true;
      gameRunning = false;
      messageEl.textContent = text + "\n(í´ë¦­í•˜ë©´ ë‹¤ì‹œ ì‹œì‘)";
    }

    function showSuccess() {
      if (gameOver) return;
      gameOver = true;
      gameRunning = false;
      messageEl.textContent = `ì„±ê³µ! ${TARGET_LEVEL}ë‹¨ê³„ ì´ë¯¸ì§€ê°€ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ‰\n(í´ë¦­í•˜ë©´ ë‹¤ì‹œ ì‹œì‘)`;
    }

    function showTimeOver() {
      if (gameOver) return;
      gameOver = true;
      gameRunning = false;
      messageEl.textContent = `ì‹œê°„ ì´ˆê³¼! ìˆœì²œë§Œì´ ìœ„í˜‘ë°›ê³  ìˆì–´ìš” ğŸ˜¢\n(í´ë¦­í•˜ë©´ ë‹¤ì‹œ ì‹œì‘)`;
    }

    function checkFailCondition() {
      for (const f of fruits) {
        if (f.isFalling || f.isMovingAfterMerge) continue;
        const topY = f.y - f.r;
        if (topY < spawnLine) return true;
      }
      return false;
    }

    // ====== ë©”ì¸ ë£¨í”„ ======
    function loop() {
      if (!gameRunning) return;

      const t = nowSec();
      const elapsed = Math.floor(t - startTime);
      timeEl.textContent = elapsed.toString();

      if (elapsed >= TIME_LIMIT) {
        timeEl.textContent = TIME_LIMIT.toString();
        showTimeOver();
        return;
      }

      const dt = t - lastTime;
      lastTime = t;

      update(dt);
      draw();

      if (!gameOver) {
        requestAnimationFrame(loop);
      }
    }

    // ====== ì—…ë°ì´íŠ¸ ======
    function update(dt) {
      // 1. ë¬¼ë¦¬
      for (const f of fruits) {
        f.update(dt);
      }

      // 2. í•©ì¹˜ê¸°
      const toRemove = new Set();
      const toAdd = [];

      for (let i = 0; i < fruits.length; i++) {
        for (let j = i + 1; j < fruits.length; j++) {
          const a = fruits[i];
          const b = fruits[j];
          if (!a || !b) continue;
          if (toRemove.has(i) || toRemove.has(j)) continue;
          if (!a.isColliding(b)) continue;

          // ê°™ì€ ë ˆë²¨ & 9 ë¯¸ë§Œ
          if (a.level === b.level && a.level !== 9 && a.canMerge && b.canMerge) {
            const newLevel = MERGE_MAP[a.level] || a.level;
            const newX = (a.x + b.x) / 2;
            const newY = (a.y + b.y) / 2;

            const nf = new Fruit(
              newX,
              newY,
              newLevel,
              (Math.random() * 6 - 3),
              -10
            );
            nf.isFalling = true;
            nf.isMovingAfterMerge = true;
            toAdd.push(nf);

            toRemove.add(i);
            toRemove.add(j);

            a.canMerge = false;
            b.canMerge = false;
            setTimeout(() => {
              a.canMerge = true;
              b.canMerge = true;
            }, 200);

            score += newLevel * 10;
            scoreEl.textContent = score.toString();

            if (newLevel === TARGET_LEVEL) {
              showSuccess();
              return;
            }
          }
        }
      }

      if (toRemove.size > 0) {
        const newList = [];
        for (let i = 0; i < fruits.length; i++) {
          if (!toRemove.has(i)) newList.push(fruits[i]);
        }
        fruits = newList;
      }
      fruits.push(...toAdd);

      // 3. ê²¹ì¹¨ ë°€ì–´ë‚´ê¸°
      for (let rep = 0; rep < 3; rep++) {
        for (let i = 0; i < fruits.length; i++) {
          for (let j = i + 1; j < fruits.length; j++) {
            const a = fruits[i];
            const b = fruits[j];
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            let dist = Math.hypot(dx, dy);
            const minDist = a.r + b.r;
            if (dist < minDist && dist > 0) {
              const overlap = (minDist - dist) * 0.5;
              const ux = dx / dist;
              const uy = dy / dist;
              a.x += ux * overlap;
              a.y += uy * overlap;
              b.x -= ux * overlap;
              b.y -= uy * overlap;
            }
          }
        }
      }

      if (checkFailCondition()) {
        showFail("ì‹¤íŒ¨! ê°¯ë²Œì´ ë„ˆë¬´ ë³µì¡í•´ì¡Œì–´ìš”!");
      }
    }

    // ====== ê·¸ë¦¬ê¸° ======
    function drawContainer(ctx) {
      ctx.save();
      ctx.fillStyle = "#5D4037";
      ctx.fillRect(containerX1, containerYTop, 10, containerHeight);
      ctx.fillRect(containerX2 - 10, containerYTop, 10, containerHeight);
      ctx.fillRect(containerX1, containerYBottom - 10, containerWidth, 10);

      ctx.setLineDash([5,5]);
      ctx.strokeStyle = "#455A64";
      ctx.beginPath();
      ctx.moveTo(containerX1, spawnLine);
      ctx.lineTo(containerX2, spawnLine);
      ctx.stroke();
      ctx.restore();
    }

    function draw() {
      // ë°°ê²½ ì´ë¯¸ì§€ê°€ ë¡œë“œë˜ì—ˆìœ¼ë©´ ë°°ê²½ ì´ë¯¸ì§€ ì‚¬ìš©
      if (backgroundImg && backgroundImg.complete) {
        ctx.drawImage(backgroundImg, 0, 0, W, H);
      } else {
        // ë¡œë”© ì „ì—ëŠ” ê·¸ë¼ë°ì´ì…˜ ë°°ê²½
        const grd = ctx.createLinearGradient(0, 0, 0, H);
        grd.addColorStop(0, "#90CAF9");
        grd.addColorStop(0.4, "#E3F2FD");
        grd.addColorStop(1, "#A5D6A7");
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, W, H);
      }

      drawContainer(ctx);

      for (const f of fruits) {
        f.draw(ctx);
      }

      if (nextFruit && !gameOver) {
        nextFruit.draw(ctx);
      }
    }

    // ====== ì‹œì‘ ======
    resetGame();
  </script>
</body>
</html>
